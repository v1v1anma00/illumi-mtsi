
import os
import datetime
import time
import multiprocessing
from multiprocessing import Queue, Process
from threading import Thread
import threading

import cv2
import numpy as np
from flask import Flask, render_template, request

from flask_object.utils.getconf import GlobalConf
from flask_object.utils.camera_utils import calculate_xyz, calibrate_pixel_focal_length, get_rtsp_wh
from flask_object.utils.image_utils import draw_image
from flask_object.detection_yolov8 import yolov8
from flask_object.utils.http_utils import post as http_post

from flask_object.utils.log_utils import init_logger
from loguru import logger

from flask_object.utils.model_utils import check_model

"""
import os
import datetime
import time
import multiprocessing
from multiprocessing import Queue, Process
from threading import Thread
import threading

import cv2
import numpy as np
import torch
import torchvision
from flask import Flask, render_template, request
from ultralytics import YOLO
from loguru import logger
import yaml
import loguru
import flask
import pygame
import pyinstaller

from flask_object.utils.getconf import GlobalConf
from flask_object.utils.camera_utils import calculate_xyz, calibrate_pixel_focal_length, get_rtsp_wh
from flask_object.utils.image_utils import draw_image
from flask_object.detection_yolov8 import yolov8
from flask_object.utils.http_utils import post as http_post
from flask_object.utils.log_utils import init_logger
from flask_object.utils.model_utils import check_model
"""
init_logger('main')

config = GlobalConf()

logger.info('当前目录{%s}' % os.getcwd())


class web_play:
    """
    web展示相关
    """

    def play(self):
        app = Flask(__name__)

        @app.after_request
        def after_request(response):
            """
            添加header解决跨域
            :param response:
            :return:
            """
            response.headers['Access-Control-Allow-Origin'] = '*'
            response.headers['Access-Control-Allow-Credentials'] = 'true'
            response.headers['Access-Control-Allow-Method'] = 'POST, GET, OPTIONS, DELETE, PATCH, PUT'
            response.headers['Access-Control-Allow-Headers'] = '*'
            return response

        @app.route('/')
        def index():
            return render_template('index.html')

        @app.route('/query')
        def query():
            config = GlobalConf()
            camera_known_object_width = config.camera_known_object_width
            camera_camera1_object_distance = config.camera_camera1_object_distance
            camera_camera1_object_pixels = config.camera_camera1_object_pixels

            camera_camera2_object_distance = config.camera_camera2_object_distance
            camera_camera2_object_pixels = config.camera_camera2_object_pixels

            camera_camera1_camera2_distance = config.camera_camera1_camera2_distance

            camera_mode = config.videos_mode
            result = {}
            result["camera_known_object_width"] = camera_known_object_width
            result["camera_camera1_object_distance"] = camera_camera1_object_distance
            result["camera_camera1_object_pixels"] = camera_camera1_object_pixels
            result["camera_camera2_object_distance"] = camera_camera2_object_distance
            result["camera_camera2_object_pixels"] = camera_camera2_object_pixels
            result["camera_camera1_camera2_distance"] = camera_camera1_camera2_distance
            result["camera_mode"] = camera_mode

            return result

        @app.route("/updateConfig", methods=['POST'])
        def updateConfig():
            config = GlobalConf()
            """共享文件主页"""
            data = request.get_json()
            config.update_config(data)
            return data

        if __name__ == '__main__':
            app.run(host='0.0.0.0', port=5008, debug=False)


class Binocular_Video_Position(object):
    def __init__(self):
        # 摄像头的初始化配置参数
        # rtsp1摄像头OK？,用于binocular_calibrate
        self.rtsp1_flag = False
        self.rtsp1 = config.videos_url1
        self.rtsp1_scale_width, self.rtsp1_scale_height = get_rtsp_wh(self.rtsp1, videos_image_scale)
        # B摄像头OK？,用于binocular_calibrate

        self.cap1 = cv2.VideoCapture(self.rtsp1)
        self.frame1_fps = int(self.cap1.get(cv2.CAP_PROP_FPS))
        self.frame_width1 = int(self.cap1.get(cv2.CAP_PROP_FRAME_WIDTH))
        self.frame_height1 = int(self.cap1.get(cv2.CAP_PROP_FRAME_HEIGHT))

    def binocular_auto_test_in(self, in_q_1, in_q_2):
        """
        双路视频流进行目标定位的自动校准，将两幅视频流进行叠加并显示
        :return:
        """
        current_thread_name = threading.current_thread().name
        logger.info('图像搜集线程:{%s}--->start' % current_thread_name)
        count = 0

        # self.cap1 = cv2.VideoCapture(self.rtsp1)
        # self.cap2 = cv2.VideoCapture(self.rtsp2)
        # 获取视频的总帧数
        frame1_fps = int(self.cap1.get(cv2.CAP_PROP_FPS))
        total_frames1 = int(self.cap1.get(cv2.CAP_PROP_FRAME_COUNT))
        frame1_count = 0

        # if not self.cap1.isOpened():
        #     self.cap1 = cv2.VideoCapture(self.rtsp1)
        # if not self.cap2.isOpened():
        #     self.cap2 = cv2.VideoCapture(self.rtsp2)

        save_flag = config.videos_save_flag
        out1, out2 = None, None

        if int(config.videos_show_flag):
            # cv2.namedWindow('show_4_in', cv2.WINDOW_NORMAL)
            pass

        if save_flag:
            frame_width1 = int(self.cap1.get(cv2.CAP_PROP_FRAME_WIDTH))
            frame_height1 = int(self.cap1.get(cv2.CAP_PROP_FRAME_HEIGHT))

            current_time = datetime.datetime.now().strftime('%Y-%m-%d-%H-%M')

            base_dir = os.path.join(os.getcwd(), 'file')
            base_dir = os.path.join(base_dir, 'videos')
            if not os.path.exists(base_dir):
                os.makedirs(base_dir)
            output1_name = os.path.join(base_dir, current_time + '_auto_in_rtsp1.avi')

            out1 = cv2.VideoWriter(output1_name, cv2.VideoWriter_fourcc('M', 'J', 'P', 'G'), frame1_fps,
                                   (frame_width1, frame_height1))  # 保存视频

        while True:
            if not self.cap1.isOpened():
                self.cap1 = cv2.VideoCapture(self.rtsp1)

            ret1, frame1 = self.cap1.read()

            frame1_count += 1

            if frame1_count == total_frames1:
                frame1_count = 0
                self.cap1.set(cv2.CAP_PROP_POS_FRAMES, 0)

            if not ret1:
                logger.warning('打开视频:{%s}:{%s}失败' % self.rtsp1)
                continue
            if frame1 is None:
                logger.warning('获取不到视频帧:{%s}:{%s}' % self.rtsp1)
                continue

            frame1 = cv2.flip(frame1, 1)
            count += 1

            # 图像缩放到合适的宽度和高度
            frame1_scale = cv2.resize(frame1, (self.rtsp1_scale_width, self.rtsp1_scale_height))

            if save_flag:
                try:
                    out1.write(frame1_scale)
                except Exception as e:
                    logger.error('保存视频出错:{%s},{%s}' % (self.rtsp1, self.rtsp2))

            if int(config.videos_show_flag):
                # cv2.imshow('show_4_in', horizontal_stack)
                pass

            # if cv2.waitKey(10) == ord('q'):
            #     break

            if not in_q_1.full():
                in_q_1.put(frame1_scale)

        if out1 is not None:
            out1.release()

        self.cap1.release()

    def binocular_auto_test_out(self, in_q_1, in_q_2, out_q_1, out_q_2, out_q_all):
        """
        双路视频流进行目标定位的自动校准，将两幅视频流进行叠加并显示
        :return:
        """
        current_thread_name = threading.current_thread().name
        logger.info('图像处理线程:{%s}--->start' % current_thread_name)
        if config.videos_save_flag:
            current_time = datetime.datetime.now().strftime('%Y-%m-%d-%H-%M')

            base_dir = os.path.join(os.getcwd(), 'file')
            base_dir = os.path.join(base_dir, 'videos')
            if not os.path.exists(base_dir):
                os.makedirs(base_dir)
            output1_name = os.path.join(base_dir, current_time + '_auto_out_rtsp1.avi')

            out1 = cv2.VideoWriter(output1_name, cv2.VideoWriter_fourcc('M', 'J', 'P', 'G'),
                                   self.frame1_fps,
                                   (self.frame_width1, self.frame_height1))  # 保存视频

        if int(config.videos_show_flag):
            cv2.namedWindow('show_5_out', cv2.WINDOW_NORMAL)

        while True:
            try:
                if in_q_1.empty():
                    time.sleep(0.01)
                else:
                    frame1 = in_q_1.get()
                    annotated_frame = yolo8.process_img(frame1)


                    if config.videos_save_flag:
                        out1.write(annotated_frame)
                    if not out_q_1.full():
                        out_q_1.put(annotated_frame)

                    if int(config.videos_show_flag):
                        # cv2.namedWindow('show_4_out', cv2.WINDOW_NORMAL)
                        cv2.imshow('show_5_out', annotated_frame)
                    if cv2.waitKey(10) == ord('q'):
                        break
            except Exception as e:
                logger.error('处理视频流异常')


def process():
    mt = Binocular_Video_Position()

    current_thread_name = threading.current_thread().name
    logger.info('线程:{%s}--->start' % current_thread_name)

    # originImageProcess = Process(target=mt.binocular_auto_test_in, args=(in_q_1, in_q_2))

    originImageProcess = Thread(target=mt.binocular_auto_test_in, args=(in_q_1, in_q_2))
    originImageProcess.start()
    #originImageProcess = Thread(target=mt.binocular_auto_test_in, args=(in_q_1, in_q_2))
    #originImageProcess.daemon = True
    #originImageProcess.start()

    # processImageProcess = Process(target=mt.binocular_auto_test_out, args=(in_q_1, in_q_2, out_q_1, out_q_2, out_q_all))
    processImageProcess = Thread(target=mt.binocular_auto_test_out,
                                 args=(in_q_1, in_q_2, out_q_1, out_q_2, out_q_all))
    processImageProcess.start()


if __name__ == "__main__":
    multiprocessing.freeze_support()
    ########################web展示相关，用于展示视频效果-start####################
    web_play_obj = web_play()
    # web_play_process = mp.Process(target=web_play_obj.play, args=( ))
    web_play_process = Thread(target=web_play_obj.play, args=( ))
    web_play_process.start()
    ########################web展示相关，用于展示视频效果-end####################

    ########################双目定位程序逻辑-start##################################
    model = config.yolov8_model
    conf = 0.3
    classes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    check_model(model)
    yolo8 = yolov8(model, conf, classes)

    # 图像缩放因子
    videos_image_scale = config.videos_image_scale

    mode = int(config.videos_mode)

    # 保存原始视频帧
    in_q_1 = Queue(30)
    in_q_2 = Queue(30)
    # 保存检测后的视频帧
    out_q_1 = Queue(30)
    out_q_2 = Queue(30)
    out_q_all = Queue(30)

    process()
